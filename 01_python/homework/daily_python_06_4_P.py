entry_record = ['이싸피', '박장고', '조실습', '이싸피', '조실습', '오디비', '임온실', '조실습', '조실습', '이싸피', '안도둑', '임온실', '최이썬', '오디비', '안도둑', '염자바', '박장고', '조실습',
                '최이썬', '조실습', '염자바', '박장고', '임온실', '임온실', '이싸피', '임온실', '오디비', '조실습', '염자바', '임온실', '박장고', '최이썬', '안도둑', '염자바', '임온실', '박장고', '이싸피', '안도둑',
                '임온실', '오디비', '최이썬', '안도둑', '이싸피', '오디비', '안도둑', '이싸피', '박장고', '박장고', '안도둑', '안도둑', '안도둑', '염자바', '최이썬', '오디비', '오디비', '최이썬', '이싸피', '임온실', '안도둑']

exit_record = ['최이썬', '조실습', '이싸피', '안도둑', '임온실', '안도둑', '이싸피', '오디비', '염자바', '박장고', '최이썬', '이싸피', '염자바', '염자바', '박장고', '임온실', '이싸피',
               '박장고', '안도둑', '염자바', '이싸피', '조실습', '조실습', '임온실', '박장고', '이싸피', '조실습', '박장고', '오디비', '안도둑', '조실습', '임온실', '안도둑', '안도둑', '임온실', '조실습', '최이썬', '안도둑', '임온실',
               '염자바', '이싸피', '임온실', '안도둑', '오디비', '안도둑', '오디비', '임온실', '염자바', '임온실', '박장고', '조실습', '이싸피', '최이썬', '최이썬', '오디비', '오디비', '염자바', '오디비', '안도둑', '박장고']

entry_dict = {} # 값을 담을 빈 딕셔너리 생성
for i in range(len(entry_record)): # 엔트리 레코드의 전 요소를 순회하며
    if entry_record[i] not in entry_dict: # 만약 딕셔너리에 이름이 없다면 이름을 추가
        entry_dict[entry_record[i]] = 0
    if entry_record[i] in entry_dict: # 딕셔너리에 이미 이름이 있다면 입장 횟수 +1회
        entry_dict[entry_record[i]] += 1

entry_dict.items() # 딕셔너리를 튜플 형태로 만들어줌
# 튜플 형태의 값을 역순으로 정렬
num_list = sorted(entry_dict.items(), key=lambda x: x[1], reverse=True)
# 문제에서 제시된 글자와 함께 정렬 정보를 이용해서 이름과 입장 기록 출력
print(f'입장 기록 많은 Top3\n{num_list[0][0]} {num_list[0][1]}\n{num_list[1][0]} {num_list[1][1]}\n{num_list[2][0]} {num_list[2][1]}')

for i in range(len(exit_record)): # 엑시트 레코드의 전 요소를 준회하며
    if exit_record[i] in entry_dict: # 딕셔너리에서 일치하는 이름을 찾는다면 숫자 -1
        entry_dict[exit_record[i]] -= 1
print('\n출입 기록이 수상한 사람') # 문제에서 요구하는 글자를 출력
for i in entry_dict:
    if entry_dict[i] > 0: # 최종 요소가 양수라면 입장 기록이 많다는 내용과 횟수 출력
        print(f'{i}은 입장 기록이 {entry_dict[i]}회 더 많아 수상합니다.')
    elif entry_dict[i] < 0: # 최종 요소가 음수라면 퇴장 기록이 많다는 내용과 횟수 출력
        print(f'{i}은 퇴장 기록이 {-entry_dict[i]}회 더 많아 수상합니다.')
    else: # 최종 요소가 0이라면, 입장과 퇴장 기록이 일치하므로 패스
        pass